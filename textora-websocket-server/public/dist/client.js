(!globalThis.EventTarget||!globalThis.Event)&&console.error(`
  PartySocket requires a global 'EventTarget' class to be available!
  You can polyfill this global by adding this to your code before any partysocket imports: 
  
  \`\`\`
  import 'partysocket/event-target-polyfill';
  \`\`\`
  Please file an issue at https://github.com/partykit/partykit if you're still having trouble.
`);var N=class extends Event{message;error;constructor(t,e){super("error",e),this.message=t.message,this.error=t}},k=class extends Event{code;reason;wasClean=!0;constructor(t=1e3,e="",s){super("close",s),this.code=t,this.reason=e}},p={Event,ErrorEvent:N,CloseEvent:k};function D(t,e){if(!t)throw new Error(e)}function U(t){return new t.constructor(t.type,t)}function M(t){return"data"in t?new MessageEvent(t.type,t):"code"in t||"reason"in t?new k(t.code||1999,t.reason||"unknown reason",t):"error"in t?new N(t.error,t):new Event(t.type,t)}var C,$=typeof process<"u"&&typeof((C=process.versions)==null?void 0:C.node)<"u"&&typeof document>"u",u=$?M:U,a={maxReconnectionDelay:1e4,minReconnectionDelay:1e3+Math.random()*4e3,minUptime:5e3,reconnectionDelayGrowFactor:1.3,connectionTimeout:4e3,maxRetries:Number.POSITIVE_INFINITY,maxEnqueuedMessages:Number.POSITIVE_INFINITY,startClosed:!1,debug:!1},S=!1,m=class h extends EventTarget{_ws;_retryCount=-1;_uptimeTimeout;_connectTimeout;_shouldReconnect=!0;_connectLock=!1;_binaryType="blob";_closeCalled=!1;_messageQueue=[];_debugLogger=console.log.bind(console);_url;_protocols;_options;constructor(e,s,o={}){super(),this._url=e,this._protocols=s,this._options=o,this._options.startClosed&&(this._shouldReconnect=!1),this._options.debugLogger&&(this._debugLogger=this._options.debugLogger),this._connect()}static get CONNECTING(){return 0}static get OPEN(){return 1}static get CLOSING(){return 2}static get CLOSED(){return 3}get CONNECTING(){return h.CONNECTING}get OPEN(){return h.OPEN}get CLOSING(){return h.CLOSING}get CLOSED(){return h.CLOSED}get binaryType(){return this._ws?this._ws.binaryType:this._binaryType}set binaryType(e){this._binaryType=e,this._ws&&(this._ws.binaryType=e)}get retryCount(){return Math.max(this._retryCount,0)}get bufferedAmount(){return this._messageQueue.reduce((s,o)=>(typeof o=="string"?s+=o.length:o instanceof Blob?s+=o.size:s+=o.byteLength,s),0)+(this._ws?this._ws.bufferedAmount:0)}get extensions(){return this._ws?this._ws.extensions:""}get protocol(){return this._ws?this._ws.protocol:""}get readyState(){return this._ws?this._ws.readyState:this._options.startClosed?h.CLOSED:h.CONNECTING}get url(){return this._ws?this._ws.url:""}get shouldReconnect(){return this._shouldReconnect}onclose=null;onerror=null;onmessage=null;onopen=null;close(e=1e3,s){if(this._closeCalled=!0,this._shouldReconnect=!1,this._clearTimeouts(),!this._ws){this._debug("close enqueued: no ws instance");return}if(this._ws.readyState===this.CLOSED){this._debug("close: already closed");return}this._ws.close(e,s)}reconnect(e,s){this._shouldReconnect=!0,this._closeCalled=!1,this._retryCount=-1,!this._ws||this._ws.readyState===this.CLOSED?this._connect():(this._disconnect(e,s),this._connect())}send(e){if(this._ws&&this._ws.readyState===this.OPEN)this._debug("send",e),this._ws.send(e);else{let{maxEnqueuedMessages:s=a.maxEnqueuedMessages}=this._options;this._messageQueue.length<s&&(this._debug("enqueue",e),this._messageQueue.push(e))}}_debug(...e){this._options.debug&&this._debugLogger("RWS>",...e)}_getNextDelay(){let{reconnectionDelayGrowFactor:e=a.reconnectionDelayGrowFactor,minReconnectionDelay:s=a.minReconnectionDelay,maxReconnectionDelay:o=a.maxReconnectionDelay}=this._options,n=0;return this._retryCount>0&&(n=s*e**(this._retryCount-1),n>o&&(n=o)),this._debug("next delay",n),n}_wait(){return new Promise(e=>{setTimeout(e,this._getNextDelay())})}_getNextProtocols(e){if(!e)return Promise.resolve(null);if(typeof e=="string"||Array.isArray(e))return Promise.resolve(e);if(typeof e=="function"){let s=e();if(!s)return Promise.resolve(null);if(typeof s=="string"||Array.isArray(s))return Promise.resolve(s);if(s.then)return s}throw Error("Invalid protocols")}_getNextUrl(e){if(typeof e=="string")return Promise.resolve(e);if(typeof e=="function"){let s=e();if(typeof s=="string")return Promise.resolve(s);if(s.then)return s}throw Error("Invalid URL")}_connect(){if(this._connectLock||!this._shouldReconnect)return;this._connectLock=!0;let{maxRetries:e=a.maxRetries,connectionTimeout:s=a.connectionTimeout}=this._options;if(this._retryCount>=e){this._debug("max retries reached",this._retryCount,">=",e);return}this._retryCount++,this._debug("connect",this._retryCount),this._removeListeners(),this._wait().then(()=>Promise.all([this._getNextUrl(this._url),this._getNextProtocols(this._protocols||null)])).then(([o,n])=>{if(this._closeCalled){this._connectLock=!1;return}!this._options.WebSocket&&typeof WebSocket>"u"&&!S&&(console.error(`\u203C\uFE0F No WebSocket implementation available. You should define options.WebSocket. 

For example, if you're using node.js, run \`npm install ws\`, and then in your code:

import PartySocket from 'partysocket';
import WS from 'ws';

const partysocket = new PartySocket({
  host: "127.0.0.1:1999",
  room: "test-room",
  WebSocket: WS
});

`),S=!0);let i=this._options.WebSocket||WebSocket;this._debug("connect",{url:o,protocols:n}),this._ws=n?new i(o,n):new i(o),this._ws.binaryType=this._binaryType,this._connectLock=!1,this._addListeners(),this._connectTimeout=setTimeout(()=>this._handleTimeout(),s)}).catch(o=>{this._connectLock=!1,this._handleError(new p.ErrorEvent(Error(o.message),this))})}_handleTimeout(){this._debug("timeout event"),this._handleError(new p.ErrorEvent(Error("TIMEOUT"),this))}_disconnect(e=1e3,s){if(this._clearTimeouts(),!!this._ws){this._removeListeners();try{(this._ws.readyState===this.OPEN||this._ws.readyState===this.CONNECTING)&&this._ws.close(e,s),this._handleClose(new p.CloseEvent(e,s,this))}catch{}}}_acceptOpen(){this._debug("accept open"),this._retryCount=0}_handleOpen=e=>{this._debug("open event");let{minUptime:s=a.minUptime}=this._options;clearTimeout(this._connectTimeout),this._uptimeTimeout=setTimeout(()=>this._acceptOpen(),s),D(this._ws,"WebSocket is not defined"),this._ws.binaryType=this._binaryType,this._messageQueue.forEach(o=>{var n;return(n=this._ws)==null?void 0:n.send(o)}),this._messageQueue=[],this.onopen&&this.onopen(e),this.dispatchEvent(u(e))};_handleMessage=e=>{this._debug("message event"),this.onmessage&&this.onmessage(e),this.dispatchEvent(u(e))};_handleError=e=>{this._debug("error event",e.message),this._disconnect(void 0,e.message==="TIMEOUT"?"timeout":void 0),this.onerror&&this.onerror(e),this._debug("exec error listeners"),this.dispatchEvent(u(e)),this._connect()};_handleClose=e=>{this._debug("close event"),this._clearTimeouts(),this._shouldReconnect&&this._connect(),this.onclose&&this.onclose(e),this.dispatchEvent(u(e))};_removeListeners(){this._ws&&(this._debug("removeListeners"),this._ws.removeEventListener("open",this._handleOpen),this._ws.removeEventListener("close",this._handleClose),this._ws.removeEventListener("message",this._handleMessage),this._ws.removeEventListener("error",this._handleError))}_addListeners(){this._ws&&(this._debug("addListeners"),this._ws.addEventListener("open",this._handleOpen),this._ws.addEventListener("close",this._handleClose),this._ws.addEventListener("message",this._handleMessage),this._ws.addEventListener("error",this._handleError))}_clearTimeouts(){clearTimeout(this._connectTimeout),clearTimeout(this._uptimeTimeout)}};var F=t=>t[1]!==null&&t[1]!==void 0;function G(){if(typeof crypto<"u"&&crypto.randomUUID)return crypto.randomUUID();let t=new Date().getTime(),e=typeof performance<"u"&&performance.now&&performance.now()*1e3||0;return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(s){let o=Math.random()*16;return t>0?(o=(t+o)%16|0,t=Math.floor(t/16)):(o=(e+o)%16|0,e=Math.floor(e/16)),(s==="x"?o:o&3|8).toString(16)})}function P(t,e,s={}){let{host:o,path:n,protocol:i,room:l,party:w,basePath:d,prefix:_,query:c}=t,r=o.replace(/^(http|https|ws|wss):\/\//,"");if(r.endsWith("/")&&(r=r.slice(0,-1)),n?.startsWith("/"))throw new Error("path must not start with a slash");let b=w??"main",v=n?`/${n}`:"",E=i||(r.startsWith("localhost:")||r.startsWith("127.0.0.1:")||r.startsWith("192.168.")||r.startsWith("10.")||r.startsWith("172.")&&r.split(".")[1]>="16"&&r.split(".")[1]<="31"||r.startsWith("[::ffff:7f00:1]:")?e:`${e}s`),x=`${E}://${r}/${d||`${_||"parties"}/${b}/${l}`}${v}`,T=(R={})=>`${x}?${new URLSearchParams([...Object.entries(s),...Object.entries(R).filter(F)])}`,O=typeof c=="function"?async()=>T(await c()):T(c);return{host:r,path:v,room:l,name:b,protocol:E,partyUrl:x,urlProvider:O}}var f=class extends m{constructor(t){var e,s;let o=L(t);super(o.urlProvider,o.protocols,o.socketOptions),this.partySocketOptions=t,this.setWSProperties(o),t.disableNameValidation||((e=t.party)!=null&&e.includes("/")&&console.warn(`PartySocket: party name "${t.party}" contains forward slash which may cause routing issues. Consider using a name without forward slashes or set disableNameValidation: true to bypass this warning.`),(s=t.room)!=null&&s.includes("/")&&console.warn(`PartySocket: room name "${t.room}" contains forward slash which may cause routing issues. Consider using a name without forward slashes or set disableNameValidation: true to bypass this warning.`))}_pk;_pkurl;name;room;host;path;updateProperties(t){let e=L({...this.partySocketOptions,...t,host:t.host??this.host,room:t.room??this.room,path:t.path??this.path});this._url=e.urlProvider,this._protocols=e.protocols,this._options=e.socketOptions,this.setWSProperties(e)}setWSProperties(t){let{_pk:e,_pkurl:s,name:o,room:n,host:i,path:l}=t;this._pk=e,this._pkurl=s,this.name=o,this.room=n,this.host=i,this.path=l}reconnect(t,e){if(!this.room||!this.host)throw new Error("The room and host must be set before connecting, use `updateProperties` method to set them or pass them to the constructor.");super.reconnect(t,e)}get id(){return this._pk}get roomUrl(){return this._pkurl}static async fetch(t,e){let s=P(t,"http"),o=typeof s.urlProvider=="string"?s.urlProvider:await s.urlProvider();return(t.fetch??fetch)(o,e)}};function L(t){let{id:e,host:s,path:o,party:n,room:i,protocol:l,query:w,protocols:d,..._}=t,c=e||G(),r=P(t,"ws",{_pk:c});return{_pk:c,_pkurl:r.partyUrl,name:r.name,room:r.room,host:r.host,path:r.path,protocols:d,socketOptions:_,urlProvider:r.urlProvider}}var I,W=document.getElementById("app");function g(t){W.appendChild(document.createTextNode(t)),W.appendChild(document.createElement("br"))}var y=new f({host:"textora-frontend-party.rheetiks.partykit.dev",room:"my-new-room"});y.addEventListener("message",t=>{g(`Received -> ${t.data}`)});y.addEventListener("open",()=>{g("Connected!"),g("Sending a ping every 2 seconds..."),clearInterval(I),I=setInterval(()=>{y.send("ping")},1e3)});
/*! Bundled license information:

partysocket/dist/chunk-ZCZZNAX5.mjs:
  (*!
   * Reconnecting WebSocket
   * by Pedro Ladaria <pedro.ladaria@gmail.com>
   * https://github.com/pladaria/reconnecting-websocket
   * License MIT
   *)
*/
//# sourceMappingURL=client.js.map
