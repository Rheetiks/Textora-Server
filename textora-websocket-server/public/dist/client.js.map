{
  "version": 3,
  "sources": ["../../node_modules/partysocket/src/ws.ts", "../../node_modules/partysocket/src/index.ts", "../../src/client.ts"],
  "sourcesContent": ["// TODO: lose this eslint-disable\n\n/*!\n * Reconnecting WebSocket\n * by Pedro Ladaria <pedro.ladaria@gmail.com>\n * https://github.com/pladaria/reconnecting-websocket\n * License MIT\n */\n\nimport type { TypedEventTarget } from \"./type-helper\";\n\nif (!globalThis.EventTarget || !globalThis.Event) {\n  console.error(`\n  PartySocket requires a global 'EventTarget' class to be available!\n  You can polyfill this global by adding this to your code before any partysocket imports: \n  \n  \\`\\`\\`\n  import 'partysocket/event-target-polyfill';\n  \\`\\`\\`\n  Please file an issue at https://github.com/partykit/partykit if you're still having trouble.\n`);\n}\n\nexport class ErrorEvent extends Event {\n  public message: string;\n  public error: Error;\n  // biome-ignore lint/suspicious/noExplicitAny: vibes\n  constructor(error: Error, target: any) {\n    super(\"error\", target);\n    this.message = error.message;\n    this.error = error;\n  }\n}\n\nexport class CloseEvent extends Event {\n  public code: number;\n  public reason: string;\n  public wasClean = true;\n  // biome-ignore lint/style/useDefaultParameterLast: legacy\n  // biome-ignore lint/suspicious/noExplicitAny: legacy\n  constructor(code = 1000, reason = \"\", target: any) {\n    super(\"close\", target);\n    this.code = code;\n    this.reason = reason;\n  }\n}\nexport interface WebSocketEventMap {\n  close: CloseEvent;\n  error: ErrorEvent;\n  message: MessageEvent;\n  open: Event;\n}\n\nconst Events = {\n  Event,\n  ErrorEvent,\n  CloseEvent\n};\n\nfunction assert(condition: unknown, msg?: string): asserts condition {\n  if (!condition) {\n    throw new Error(msg);\n  }\n}\n\nfunction cloneEventBrowser(e: Event) {\n  // biome-ignore lint/suspicious/noExplicitAny: legacy\n  return new (e as any).constructor(e.type, e) as Event;\n}\n\nfunction cloneEventNode(e: Event) {\n  if (\"data\" in e) {\n    const evt = new MessageEvent(e.type, e);\n    return evt;\n  }\n\n  if (\"code\" in e || \"reason\" in e) {\n    const evt = new CloseEvent(\n      // @ts-expect-error we need to fix event/listener types\n      (e.code || 1999) as number,\n      // @ts-expect-error we need to fix event/listener types\n      (e.reason || \"unknown reason\") as string,\n      e\n    );\n    return evt;\n  }\n\n  if (\"error\" in e) {\n    const evt = new ErrorEvent(e.error as Error, e);\n    return evt;\n  }\n\n  const evt = new Event(e.type, e);\n  return evt;\n}\n\nconst isNode =\n  typeof process !== \"undefined\" &&\n  typeof process.versions?.node !== \"undefined\" &&\n  typeof document === \"undefined\";\n\nconst cloneEvent = isNode ? cloneEventNode : cloneEventBrowser;\n\nexport type Options = {\n  // biome-ignore lint/suspicious/noExplicitAny: legacy\n  WebSocket?: any;\n  maxReconnectionDelay?: number;\n  minReconnectionDelay?: number;\n  reconnectionDelayGrowFactor?: number;\n  minUptime?: number;\n  connectionTimeout?: number;\n  maxRetries?: number;\n  maxEnqueuedMessages?: number;\n  startClosed?: boolean;\n  debug?: boolean;\n  // biome-ignore lint/suspicious/noExplicitAny: legacy\n  debugLogger?: (...args: any[]) => void;\n};\n\nconst DEFAULT = {\n  maxReconnectionDelay: 10000,\n  minReconnectionDelay: 1000 + Math.random() * 4000,\n  minUptime: 5000,\n  reconnectionDelayGrowFactor: 1.3,\n  connectionTimeout: 4000,\n  maxRetries: Number.POSITIVE_INFINITY,\n  maxEnqueuedMessages: Number.POSITIVE_INFINITY,\n  startClosed: false,\n  debug: false\n};\n\nlet didWarnAboutMissingWebSocket = false;\n\nexport type UrlProvider = string | (() => string) | (() => Promise<string>);\nexport type ProtocolsProvider =\n  | null\n  | string\n  | string[]\n  | (() => string | string[] | null)\n  | (() => Promise<string | string[] | null>);\n\nexport type Message = string | ArrayBuffer | Blob | ArrayBufferView;\n\nexport default class ReconnectingWebSocket extends (EventTarget as TypedEventTarget<WebSocketEventMap>) {\n  private _ws: WebSocket | undefined;\n  private _retryCount = -1;\n  private _uptimeTimeout: ReturnType<typeof setTimeout> | undefined;\n  private _connectTimeout: ReturnType<typeof setTimeout> | undefined;\n  private _shouldReconnect = true;\n  private _connectLock = false;\n  private _binaryType: BinaryType = \"blob\";\n  private _closeCalled = false;\n  private _messageQueue: Message[] = [];\n\n  private _debugLogger = console.log.bind(console);\n\n  protected _url: UrlProvider;\n  protected _protocols?: ProtocolsProvider;\n  protected _options: Options;\n\n  constructor(\n    url: UrlProvider,\n    protocols?: ProtocolsProvider,\n    options: Options = {}\n  ) {\n    super();\n    this._url = url;\n    this._protocols = protocols;\n    this._options = options;\n    if (this._options.startClosed) {\n      this._shouldReconnect = false;\n    }\n    if (this._options.debugLogger) {\n      this._debugLogger = this._options.debugLogger;\n    }\n    this._connect();\n  }\n\n  static get CONNECTING() {\n    return 0;\n  }\n  static get OPEN() {\n    return 1;\n  }\n  static get CLOSING() {\n    return 2;\n  }\n  static get CLOSED() {\n    return 3;\n  }\n\n  get CONNECTING() {\n    return ReconnectingWebSocket.CONNECTING;\n  }\n  get OPEN() {\n    return ReconnectingWebSocket.OPEN;\n  }\n  get CLOSING() {\n    return ReconnectingWebSocket.CLOSING;\n  }\n  get CLOSED() {\n    return ReconnectingWebSocket.CLOSED;\n  }\n\n  get binaryType() {\n    return this._ws ? this._ws.binaryType : this._binaryType;\n  }\n\n  set binaryType(value: BinaryType) {\n    this._binaryType = value;\n    if (this._ws) {\n      this._ws.binaryType = value;\n    }\n  }\n\n  /**\n   * Returns the number or connection retries\n   */\n  get retryCount(): number {\n    return Math.max(this._retryCount, 0);\n  }\n\n  /**\n   * The number of bytes of data that have been queued using calls to send() but not yet\n   * transmitted to the network. This value resets to zero once all queued data has been sent.\n   * This value does not reset to zero when the connection is closed; if you keep calling send(),\n   * this will continue to climb. Read only\n   */\n  get bufferedAmount(): number {\n    const bytes = this._messageQueue.reduce((acc, message) => {\n      if (typeof message === \"string\") {\n        acc += message.length; // not byte size\n      } else if (message instanceof Blob) {\n        acc += message.size;\n      } else {\n        acc += message.byteLength;\n      }\n      return acc;\n    }, 0);\n    return bytes + (this._ws ? this._ws.bufferedAmount : 0);\n  }\n\n  /**\n   * The extensions selected by the server. This is currently only the empty string or a list of\n   * extensions as negotiated by the connection\n   */\n  get extensions(): string {\n    return this._ws ? this._ws.extensions : \"\";\n  }\n\n  /**\n   * A string indicating the name of the sub-protocol the server selected;\n   * this will be one of the strings specified in the protocols parameter when creating the\n   * WebSocket object\n   */\n  get protocol(): string {\n    return this._ws ? this._ws.protocol : \"\";\n  }\n\n  /**\n   * The current state of the connection; this is one of the Ready state constants\n   */\n  get readyState(): number {\n    if (this._ws) {\n      return this._ws.readyState;\n    }\n    return this._options.startClosed\n      ? ReconnectingWebSocket.CLOSED\n      : ReconnectingWebSocket.CONNECTING;\n  }\n\n  /**\n   * The URL as resolved by the constructor\n   */\n  get url(): string {\n    return this._ws ? this._ws.url : \"\";\n  }\n\n  /**\n   * Whether the websocket object is now in reconnectable state\n   */\n  get shouldReconnect(): boolean {\n    return this._shouldReconnect;\n  }\n\n  /**\n   * An event listener to be called when the WebSocket connection's readyState changes to CLOSED\n   */\n  public onclose: ((event: CloseEvent) => void) | null = null;\n\n  /**\n   * An event listener to be called when an error occurs\n   */\n  public onerror: ((event: ErrorEvent) => void) | null = null;\n\n  /**\n   * An event listener to be called when a message is received from the server\n   */\n  public onmessage: ((event: MessageEvent) => void) | null = null;\n\n  /**\n   * An event listener to be called when the WebSocket connection's readyState changes to OPEN;\n   * this indicates that the connection is ready to send and receive data\n   */\n  public onopen: ((event: Event) => void) | null = null;\n\n  /**\n   * Closes the WebSocket connection or connection attempt, if any. If the connection is already\n   * CLOSED, this method does nothing\n   */\n  public close(code = 1000, reason?: string) {\n    this._closeCalled = true;\n    this._shouldReconnect = false;\n    this._clearTimeouts();\n    if (!this._ws) {\n      this._debug(\"close enqueued: no ws instance\");\n      return;\n    }\n    if (this._ws.readyState === this.CLOSED) {\n      this._debug(\"close: already closed\");\n      return;\n    }\n    this._ws.close(code, reason);\n  }\n\n  /**\n   * Closes the WebSocket connection or connection attempt and connects again.\n   * Resets retry counter;\n   */\n  public reconnect(code?: number, reason?: string) {\n    this._shouldReconnect = true;\n    this._closeCalled = false;\n    this._retryCount = -1;\n    if (!this._ws || this._ws.readyState === this.CLOSED) {\n      this._connect();\n    } else {\n      this._disconnect(code, reason);\n      this._connect();\n    }\n  }\n\n  /**\n   * Enqueue specified data to be transmitted to the server over the WebSocket connection\n   */\n  public send(data: Message) {\n    if (this._ws && this._ws.readyState === this.OPEN) {\n      this._debug(\"send\", data);\n      this._ws.send(data);\n    } else {\n      const { maxEnqueuedMessages = DEFAULT.maxEnqueuedMessages } =\n        this._options;\n      if (this._messageQueue.length < maxEnqueuedMessages) {\n        this._debug(\"enqueue\", data);\n        this._messageQueue.push(data);\n      }\n    }\n  }\n\n  private _debug(...args: unknown[]) {\n    if (this._options.debug) {\n      this._debugLogger(\"RWS>\", ...args);\n    }\n  }\n\n  private _getNextDelay() {\n    const {\n      reconnectionDelayGrowFactor = DEFAULT.reconnectionDelayGrowFactor,\n      minReconnectionDelay = DEFAULT.minReconnectionDelay,\n      maxReconnectionDelay = DEFAULT.maxReconnectionDelay\n    } = this._options;\n    let delay = 0;\n    if (this._retryCount > 0) {\n      delay =\n        minReconnectionDelay *\n        reconnectionDelayGrowFactor ** (this._retryCount - 1);\n      if (delay > maxReconnectionDelay) {\n        delay = maxReconnectionDelay;\n      }\n    }\n    this._debug(\"next delay\", delay);\n    return delay;\n  }\n\n  private _wait(): Promise<void> {\n    return new Promise((resolve) => {\n      setTimeout(resolve, this._getNextDelay());\n    });\n  }\n\n  private _getNextProtocols(\n    protocolsProvider: ProtocolsProvider | null\n  ): Promise<string | string[] | null> {\n    if (!protocolsProvider) return Promise.resolve(null);\n\n    if (\n      typeof protocolsProvider === \"string\" ||\n      Array.isArray(protocolsProvider)\n    ) {\n      return Promise.resolve(protocolsProvider);\n    }\n\n    if (typeof protocolsProvider === \"function\") {\n      const protocols = protocolsProvider();\n      if (!protocols) return Promise.resolve(null);\n\n      if (typeof protocols === \"string\" || Array.isArray(protocols)) {\n        return Promise.resolve(protocols);\n      }\n\n      // @ts-expect-error redundant check\n      if (protocols.then) {\n        return protocols;\n      }\n    }\n\n    throw Error(\"Invalid protocols\");\n  }\n\n  private _getNextUrl(urlProvider: UrlProvider): Promise<string> {\n    if (typeof urlProvider === \"string\") {\n      return Promise.resolve(urlProvider);\n    }\n    if (typeof urlProvider === \"function\") {\n      const url = urlProvider();\n      if (typeof url === \"string\") {\n        return Promise.resolve(url);\n      }\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      if (url.then) {\n        return url;\n      }\n\n      // return url;\n    }\n    throw Error(\"Invalid URL\");\n  }\n\n  private _connect() {\n    if (this._connectLock || !this._shouldReconnect) {\n      return;\n    }\n    this._connectLock = true;\n\n    const {\n      maxRetries = DEFAULT.maxRetries,\n      connectionTimeout = DEFAULT.connectionTimeout\n    } = this._options;\n\n    if (this._retryCount >= maxRetries) {\n      this._debug(\"max retries reached\", this._retryCount, \">=\", maxRetries);\n      return;\n    }\n\n    this._retryCount++;\n\n    this._debug(\"connect\", this._retryCount);\n    this._removeListeners();\n\n    this._wait()\n      .then(() =>\n        Promise.all([\n          this._getNextUrl(this._url),\n          this._getNextProtocols(this._protocols || null)\n        ])\n      )\n      .then(([url, protocols]) => {\n        // close could be called before creating the ws\n        if (this._closeCalled) {\n          this._connectLock = false;\n          return;\n        }\n        if (\n          !this._options.WebSocket &&\n          typeof WebSocket === \"undefined\" &&\n          !didWarnAboutMissingWebSocket\n        ) {\n          console.error(`‼️ No WebSocket implementation available. You should define options.WebSocket. \n\nFor example, if you're using node.js, run \\`npm install ws\\`, and then in your code:\n\nimport PartySocket from 'partysocket';\nimport WS from 'ws';\n\nconst partysocket = new PartySocket({\n  host: \"127.0.0.1:1999\",\n  room: \"test-room\",\n  WebSocket: WS\n});\n\n`);\n          didWarnAboutMissingWebSocket = true;\n        }\n        const WS: typeof WebSocket = this._options.WebSocket || WebSocket;\n        this._debug(\"connect\", { url, protocols });\n        this._ws = protocols ? new WS(url, protocols) : new WS(url);\n\n        this._ws.binaryType = this._binaryType;\n        this._connectLock = false;\n        this._addListeners();\n\n        this._connectTimeout = setTimeout(\n          () => this._handleTimeout(),\n          connectionTimeout\n        );\n      })\n      // via https://github.com/pladaria/reconnecting-websocket/pull/166\n      .catch((err) => {\n        this._connectLock = false;\n        this._handleError(new Events.ErrorEvent(Error(err.message), this));\n      });\n  }\n\n  private _handleTimeout() {\n    this._debug(\"timeout event\");\n    this._handleError(new Events.ErrorEvent(Error(\"TIMEOUT\"), this));\n  }\n\n  private _disconnect(code = 1000, reason?: string) {\n    this._clearTimeouts();\n    if (!this._ws) {\n      return;\n    }\n    this._removeListeners();\n    try {\n      if (\n        this._ws.readyState === this.OPEN ||\n        this._ws.readyState === this.CONNECTING\n      ) {\n        this._ws.close(code, reason);\n      }\n      this._handleClose(new Events.CloseEvent(code, reason, this));\n    } catch (error) {\n      // ignore\n    }\n  }\n\n  private _acceptOpen() {\n    this._debug(\"accept open\");\n    this._retryCount = 0;\n  }\n\n  private _handleOpen = (event: Event) => {\n    this._debug(\"open event\");\n    const { minUptime = DEFAULT.minUptime } = this._options;\n\n    clearTimeout(this._connectTimeout);\n    this._uptimeTimeout = setTimeout(() => this._acceptOpen(), minUptime);\n\n    assert(this._ws, \"WebSocket is not defined\");\n\n    this._ws.binaryType = this._binaryType;\n\n    // send enqueued messages (messages sent before websocket open event)\n    this._messageQueue.forEach((message) => this._ws?.send(message));\n    this._messageQueue = [];\n\n    if (this.onopen) {\n      this.onopen(event);\n    }\n    this.dispatchEvent(cloneEvent(event));\n  };\n\n  private _handleMessage = (event: MessageEvent) => {\n    this._debug(\"message event\");\n\n    if (this.onmessage) {\n      this.onmessage(event);\n    }\n    this.dispatchEvent(cloneEvent(event));\n  };\n\n  private _handleError = (event: ErrorEvent) => {\n    this._debug(\"error event\", event.message);\n    this._disconnect(\n      undefined,\n      event.message === \"TIMEOUT\" ? \"timeout\" : undefined\n    );\n\n    if (this.onerror) {\n      this.onerror(event);\n    }\n    this._debug(\"exec error listeners\");\n    this.dispatchEvent(cloneEvent(event));\n\n    this._connect();\n  };\n\n  private _handleClose = (event: CloseEvent) => {\n    this._debug(\"close event\");\n    this._clearTimeouts();\n\n    if (this._shouldReconnect) {\n      this._connect();\n    }\n\n    if (this.onclose) {\n      this.onclose(event);\n    }\n    this.dispatchEvent(cloneEvent(event));\n  };\n\n  private _removeListeners() {\n    if (!this._ws) {\n      return;\n    }\n    this._debug(\"removeListeners\");\n    this._ws.removeEventListener(\"open\", this._handleOpen);\n    this._ws.removeEventListener(\"close\", this._handleClose);\n    this._ws.removeEventListener(\"message\", this._handleMessage);\n    // @ts-expect-error we need to fix event/listerner types\n    this._ws.removeEventListener(\"error\", this._handleError);\n  }\n\n  private _addListeners() {\n    if (!this._ws) {\n      return;\n    }\n    this._debug(\"addListeners\");\n    this._ws.addEventListener(\"open\", this._handleOpen);\n    this._ws.addEventListener(\"close\", this._handleClose);\n    this._ws.addEventListener(\"message\", this._handleMessage);\n    // @ts-expect-error we need to fix event/listener types\n    this._ws.addEventListener(\"error\", this._handleError);\n  }\n\n  private _clearTimeouts() {\n    clearTimeout(this._connectTimeout);\n    clearTimeout(this._uptimeTimeout);\n  }\n}\n", "import ReconnectingWebSocket from \"./ws\";\n\nimport type * as RWS from \"./ws\";\n\ntype Maybe<T> = T | null | undefined;\ntype Params = Record<string, Maybe<string>>;\nconst valueIsNotNil = <T>(\n  keyValuePair: [string, Maybe<T>]\n): keyValuePair is [string, T] =>\n  keyValuePair[1] !== null && keyValuePair[1] !== undefined;\n\nexport type PartySocketOptions = Omit<RWS.Options, \"constructor\"> & {\n  id?: string; // the id of the client\n  host: string; // base url for the party\n  room?: string; // the room to connect to\n  party?: string; // the party to connect to (defaults to main)\n  basePath?: string; // the base path to use for the party\n  prefix?: string; // the prefix to use for the party\n  protocol?: \"ws\" | \"wss\";\n  protocols?: string[];\n  path?: string; // the path to connect to\n  query?: Params | (() => Params | Promise<Params>);\n  disableNameValidation?: boolean; // disable validation of party/room names\n  // headers\n};\n\nexport type PartyFetchOptions = {\n  host: string; // base url for the party\n  room: string; // the room to connect to\n  party?: string; // the party to fetch from (defaults to main)\n  basePath?: string; // the base path to use for the party\n  prefix?: string; // the prefix to use for the party\n  path?: string; // the path to fetch from\n  protocol?: \"http\" | \"https\";\n  query?: Params | (() => Params | Promise<Params>);\n  fetch?: typeof fetch;\n};\n\nfunction generateUUID(): string {\n  // Public Domain/MIT\n  if (typeof crypto !== \"undefined\" && crypto.randomUUID) {\n    return crypto.randomUUID();\n  }\n  let d = new Date().getTime(); //Timestamp\n  let d2 =\n    (typeof performance !== \"undefined\" &&\n      performance.now &&\n      performance.now() * 1000) ||\n    0; //Time in microseconds since page-load or 0 if unsupported\n  // biome-ignore lint/complexity/useArrowFunction: <explanation>\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n    let r = Math.random() * 16; //random number between 0 and 16\n    if (d > 0) {\n      //Use timestamp until depleted\n      r = (d + r) % 16 | 0;\n      d = Math.floor(d / 16);\n    } else {\n      //Use microseconds since page-load if supported\n      r = (d2 + r) % 16 | 0;\n      d2 = Math.floor(d2 / 16);\n    }\n    return (c === \"x\" ? r : (r & 0x3) | 0x8).toString(16);\n  });\n}\n\nfunction getPartyInfo(\n  partySocketOptions: PartySocketOptions | PartyFetchOptions,\n  defaultProtocol: \"http\" | \"ws\",\n  defaultParams: Record<string, string> = {}\n) {\n  const {\n    host: rawHost,\n    path: rawPath,\n    protocol: rawProtocol,\n    room,\n    party,\n    basePath,\n    prefix,\n    query\n  } = partySocketOptions;\n\n  // strip the protocol from the beginning of `host` if any\n  let host = rawHost.replace(/^(http|https|ws|wss):\\/\\//, \"\");\n  // if user provided a trailing slash, remove it\n  if (host.endsWith(\"/\")) {\n    host = host.slice(0, -1);\n  }\n\n  if (rawPath?.startsWith(\"/\")) {\n    throw new Error(\"path must not start with a slash\");\n  }\n\n  const name = party ?? \"main\";\n  const path = rawPath ? `/${rawPath}` : \"\";\n  const protocol =\n    rawProtocol ||\n    (host.startsWith(\"localhost:\") ||\n    host.startsWith(\"127.0.0.1:\") ||\n    host.startsWith(\"192.168.\") ||\n    host.startsWith(\"10.\") ||\n    (host.startsWith(\"172.\") &&\n      host.split(\".\")[1] >= \"16\" &&\n      host.split(\".\")[1] <= \"31\") ||\n    host.startsWith(\"[::ffff:7f00:1]:\")\n      ? // http / ws\n        defaultProtocol\n      : // https / wss\n        `${defaultProtocol}s`);\n\n  const baseUrl = `${protocol}://${host}/${basePath || `${prefix || \"parties\"}/${name}/${room}`}${path}`;\n\n  const makeUrl = (query: Params = {}) =>\n    `${baseUrl}?${new URLSearchParams([\n      ...Object.entries(defaultParams),\n      ...Object.entries(query).filter(valueIsNotNil)\n    ])}`;\n\n  // allow urls to be defined as functions\n  const urlProvider =\n    typeof query === \"function\"\n      ? async () => makeUrl(await query())\n      : makeUrl(query);\n\n  return {\n    host,\n    path,\n    room,\n    name,\n    protocol,\n    partyUrl: baseUrl,\n    urlProvider\n  };\n}\n\n// things that nathanboktae/robust-websocket claims are better:\n// doesn't do anything in offline mode (?)\n// \"natively aware of error codes\"\n// can do custom reconnect strategies\n\n// TODO: incorporate the above notes\nexport default class PartySocket extends ReconnectingWebSocket {\n  _pk!: string;\n  _pkurl!: string;\n  name!: string;\n  room?: string;\n  host!: string;\n  path!: string;\n\n  constructor(readonly partySocketOptions: PartySocketOptions) {\n    const wsOptions = getWSOptions(partySocketOptions);\n\n    super(wsOptions.urlProvider, wsOptions.protocols, wsOptions.socketOptions);\n\n    this.setWSProperties(wsOptions);\n\n    if (!partySocketOptions.disableNameValidation) {\n      if (partySocketOptions.party?.includes(\"/\")) {\n        console.warn(\n          `PartySocket: party name \"${partySocketOptions.party}\" contains forward slash which may cause routing issues. Consider using a name without forward slashes or set disableNameValidation: true to bypass this warning.`\n        );\n      }\n      if (partySocketOptions.room?.includes(\"/\")) {\n        console.warn(\n          `PartySocket: room name \"${partySocketOptions.room}\" contains forward slash which may cause routing issues. Consider using a name without forward slashes or set disableNameValidation: true to bypass this warning.`\n        );\n      }\n    }\n  }\n\n  public updateProperties(partySocketOptions: Partial<PartySocketOptions>) {\n    const wsOptions = getWSOptions({\n      ...this.partySocketOptions,\n      ...partySocketOptions,\n      host: partySocketOptions.host ?? this.host,\n      room: partySocketOptions.room ?? this.room,\n      path: partySocketOptions.path ?? this.path\n    });\n\n    this._url = wsOptions.urlProvider;\n    this._protocols = wsOptions.protocols;\n    this._options = wsOptions.socketOptions;\n\n    this.setWSProperties(wsOptions);\n  }\n\n  private setWSProperties(wsOptions: ReturnType<typeof getWSOptions>) {\n    const { _pk, _pkurl, name, room, host, path } = wsOptions;\n\n    this._pk = _pk;\n    this._pkurl = _pkurl;\n    this.name = name;\n    this.room = room;\n    this.host = host;\n    this.path = path;\n  }\n\n  public reconnect(\n    code?: number | undefined,\n    reason?: string | undefined\n  ): void {\n    if (!this.room || !this.host) {\n      throw new Error(\n        \"The room and host must be set before connecting, use `updateProperties` method to set them or pass them to the constructor.\"\n      );\n    }\n    super.reconnect(code, reason);\n  }\n\n  get id() {\n    return this._pk;\n  }\n\n  /**\n   * Exposes the static PartyKit room URL without applying query parameters.\n   * To access the currently connected WebSocket url, use PartySocket#url.\n   */\n  get roomUrl(): string {\n    return this._pkurl;\n  }\n\n  // a `fetch` method that uses (almost) the same options as `PartySocket`\n  static async fetch(\n    options: PartyFetchOptions,\n    init?: RequestInit\n  ): Promise<Response> {\n    const party = getPartyInfo(options, \"http\");\n    const url =\n      typeof party.urlProvider === \"string\"\n        ? party.urlProvider\n        : await party.urlProvider();\n    const doFetch = options.fetch ?? fetch;\n    return doFetch(url, init);\n  }\n}\n\nexport { PartySocket };\n\nexport { ReconnectingWebSocket as WebSocket };\n\nfunction getWSOptions(partySocketOptions: PartySocketOptions) {\n  const {\n    id,\n    host: _host,\n    path: _path,\n    party: _party,\n    room: _room,\n    protocol: _protocol,\n    query: _query,\n    protocols,\n    ...socketOptions\n  } = partySocketOptions;\n\n  const _pk = id || generateUUID();\n  const party = getPartyInfo(partySocketOptions, \"ws\", { _pk });\n\n  return {\n    _pk: _pk,\n    _pkurl: party.partyUrl,\n    name: party.name,\n    room: party.room,\n    host: party.host,\n    path: party.path,\n    protocols: protocols,\n    socketOptions: socketOptions,\n    urlProvider: party.urlProvider\n  };\n}\n", "import \"./styles.css\";\n\nimport PartySocket from \"partysocket\";\n\ndeclare const PARTYKIT_HOST: string;\n\nlet pingInterval: ReturnType<typeof setInterval>;\n\n// Let's append all the messages we get into this DOM element\nconst output = document.getElementById(\"app\") as HTMLDivElement;\n\n// Helper function to add a new line to the DOM\nfunction add(text: string) {\n  output.appendChild(document.createTextNode(text));\n  output.appendChild(document.createElement(\"br\"));\n}\n\n// A PartySocket is like a WebSocket, except it's a bit more magical.\n// It handles reconnection logic, buffering messages while it's offline, and more.\nconst conn = new PartySocket({\n  host: PARTYKIT_HOST,\n  room: \"my-new-room\",\n});\n\n// You can even start sending messages before the connection is open!\nconn.addEventListener(\"message\", (event) => {\n  add(`Received -> ${event.data}`);\n});\n\n// Let's listen for when the connection opens\n// And send a ping every 2 seconds right after\nconn.addEventListener(\"open\", () => {\n  add(\"Connected!\");\n  add(\"Sending a ping every 2 seconds...\");\n  // TODO: make this more interesting / nice\n  clearInterval(pingInterval);\n  pingInterval = setInterval(() => {\n    conn.send(\"ping\");\n  }, 1000);\n});\n"],
  "mappings": "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",
  "names": ["ErrorEvent", "error", "target", "CloseEvent", "code", "reason", "Events", "assert", "condition", "msg", "cloneEventBrowser", "e", "cloneEventNode", "_a", "isNode", "cloneEvent", "DEFAULT", "didWarnAboutMissingWebSocket", "ReconnectingWebSocket", "_ReconnectingWebSocket", "url", "protocols", "options", "value", "acc", "message", "data", "maxEnqueuedMessages", "args", "reconnectionDelayGrowFactor", "minReconnectionDelay", "maxReconnectionDelay", "delay", "resolve", "protocolsProvider", "urlProvider", "maxRetries", "connectionTimeout", "WS", "err", "event", "minUptime", "_a2", "generateUUID", "d", "d2", "c", "r", "getPartyInfo", "partySocketOptions", "defaultProtocol", "defaultParams", "rawHost", "rawPath", "rawProtocol", "room", "party", "basePath", "prefix", "query", "host", "name", "path", "protocol", "baseUrl", "makeUrl", "query2", "valueIsNotNil", "urlProvider", "PartySocket", "ReconnectingWebSocket", "_a", "_b", "wsOptions", "getWSOptions", "_pk", "_pkurl", "code", "reason", "options", "init", "url", "id", "_host", "_path", "_party", "_room", "_protocol", "_query", "pingInterval", "output", "add", "text", "conn", "PartySocket", "event"]
}
